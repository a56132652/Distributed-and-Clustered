# 1. 封装INetServer与INetClientS

保留底层webSocket通信协议内容

## 1.1 INetServer

**网关服务器**

- **功能**：
  - 注册API
  - 分发消息
  - 限流
    - 限制客户端的请求量，但对于上层服务器的返回的响应消息不进行限流

## 1.2 INetClientS

**用于管理连接的客户端对象**

# 2. 封装INetClient

保留底层webSocket客户端功能



# 3. 注册网络消息回调

旧版本的消息处理逻辑中，默认已经知道了消息类型，根据接收到的消息的类型来进行不同的处理，这不便于灵活处理消息，因此，为了灵活处理消息，即不论什么消息类型都能回复，**需要提供未知消息类型的注册机制**

## 3.1 利用回调函数注册消息

```c++
typedef std::function<void(Server*, INetClientS*, neb::CJsonObject&)> NetEventCall;
```

**利用map存储事件回调**

```c++
std::map<std::string, NetEventCall> _map_msg_call;
```

**注册消息**

```c++
void reg_msg_call(std::string cmd, NetEventCall call)
	{
		_map_msg_call[cmd] = call;
		CELLLog_Info("INetServer::reg_msg_call cmd<%s>.", cmd.c_str());
	}
```

**根据消息调用回调**

```c++
bool on_net_msg_do(Server* pServer, INetClientS* pWSClient, std::string& cmd, neb::CJsonObject& msgJson)
{
	auto itr = _map_msg_call.find(cmd);
	if (itr != _map_msg_call.end())
	{
		itr->second(pServer, pWSClient, msgJson);
		return true;
	}
	CELLLog_Info("%s::INetServer::on_net_msg_do not found cmd<%s>.", pWSClient->link_name().c_str(), cmd.c_str());
	return false;
}
```

# 4. 建立网关服务器GateServer

**当前，多平台客户端发起的请求都发送给了网关服务器，然后网关服务器进而将请求分发给不同的服务器进行处理，比如登录请求发送给登录服务器，支付请求发送给支付服务器等等。**

## 4.1 在GateServer中注册回调函数

- 注册心跳消息回调函数

```c++
//std::bind() c++11新方法 std::placeholders::_1占位符
/*
可将bind函数看作是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。
调用bind的一般形式：auto newCallable = bind(callable,arg_list);
其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable,并传给它arg_list中的参数。
*/

//收到心跳消息(cs_msg_heart)时调用GateServer::cs_msg_heart()函数
_netserver.reg_msg_call("cs_msg_heart", std::bind(&GateServer::cs_msg_heart, this,std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));

void cs_msg_heart(Server* server, INetClientS* client, neb::CJsonObject& msg)
{
	CELLLog_Info("GateServer::cs_msg_heart");

	neb::CJsonObject ret;
	ret.Add("data", "wo ye bu ji dao.");
	client->response(msg, ret);
	//client->respone(msg, "wo ye bu ji dao.");
}

```

- 注册 注册请求消息 回调函数

```c++
_netserver.reg_msg_call("ss_reg_api", std::bind(&GateServer::ss_reg_api, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));

//响应LoginServer注册服务请求
void ss_reg_api(Server* server, INetClientS* client, neb::CJsonObject& msg)
{
	auto sskey = msg["data"]("sskey");
	auto sskey_local = Config::Instance().getStr("sskey", "ssmm00@123456");
	if (sskey != sskey_local)
	{
		neb::CJsonObject ret;
		//状态码 state 0-fail ,1-success
		ret.Add("state", 0);
		ret.Add("msg", "sskey error.");
		client->response(msg, ret);
		return;
	}
	//客户端类型
	auto type = msg["data"]("type");
	//客户端名称
	auto name = msg["data"]("name");

	client->link_type(type);
	client->link_name(name);
	client->is_ss_link(true);
	/*
        msg["data"]("type"):返回 "type" 字段所对应的字符串
        msg["data"]["apis"]:返回 "apis" 字段所对应的json结构，结构下又包含字符串
	*/
	auto apis = msg["data"]["apis"];

	if (!apis.IsArray())
	{
		neb::CJsonObject ret;
		ret.Add("state", 0);
		ret.Add("msg", "not found apis.");
		client->response(msg, ret);
		return;
	}
	int size = apis.GetArraySize();
	for (size_t i = 0; i < size; i++)
	{
		CELLLog_Info("ss_reg_api: %s >> %s", name.c_str(), apis(i).c_str());
		_transfer.add(apis(i), client);
	}
}
```

- 注册其他消息即客户端离开消息回调

```c++
_netserver.on_other_msg = std::bind(&GateServer::on_other_msg, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4);
_netserver.on_client_leave = std::bind(&GateServer::on_client_leave, this, std::placeholders::_1);

void on_other_msg(Server* server, INetClientS* client, std::string& cmd, neb::CJsonObject& msg)
{
	auto str = msg.ToString();
	if (!_transfer.on_net_msg_do(cmd, str))
	{
		CELLLog_Info("on_other_msg: transfer not found cmd<%s>.", cmd.c_str());
	}
}

void on_client_leave(INetClientS* client)
{
	if(client->is_ss_link())
		_transfer.del(client);
}
```



# 5. 建立登录服务器LoginServer

**登陆服务器首先与网关服务器建立连接，在该`C~S`模型中LoginServer为客户端，GateServer为服务端**

- LoginServer首先发起连接请求，连接完成后向GateServer发起注册服务请求
  - 即告知GateServer自己关注何种类型的消息，注册成功后，当GateServer收到该类型消息时，会将其分发给LoginServer

## 5.1 注册回调函数

- 注册 onopen 回调

```c++
_csGate.reg_msg_call("onopen", std::bind(&LoginServer::onopen_csGate, this, std::placeholders::_1, std::placeholders::_2));
//收到 onopen 消息时的回调，收到onopen消息后向网关服务器发起注册服务请求
void onopen_csGate(INetClient* client, neb::CJsonObject& msg)
{
	neb::CJsonObject json;
	//告知网关自己是什么类型的服务
	json.Add("type", "LoginServer");
	//自己的名字
	json.Add("name", "LoginServer001");
	//校验机制，网关服务器会校验该值
	json.Add("sskey", "ssmm00@123456");
	json.AddEmptySubArray("apis");
	/*
		告知网关自己关心什么类型的消息
		网关收到该类型的消息到会分发给自己
	*/
	//登录
	json["apis"].Add("cs_msg_login");
	//注册
	json["apis"].Add("cs_msg_register");
	//改密码
	json["apis"].Add("cs_msg_change_pw");
	client->request("ss_reg_api", json);
}
```

- 心跳消息以及登录消息回调

```c++
_csGate.reg_msg_call("cs_msg_heart", std::bind(&LoginServer::cs_msg_heart, this,std::placeholders::_1, std::placeholders::_2));
_csGate.reg_msg_call("cs_msg_login", std::bind(&LoginServer::cs_msg_login, this, std::placeholders::_1, std::placeholders::_2));

void cs_msg_heart(INetClient* client, neb::CJsonObject& msg)
{
	CELLLog_Info("LoginServer::cs_msg_heart");

	neb::CJsonObject ret;
	ret.Add("data", "wo ye bu ji dao.");
	client->response(msg, ret);

	//client->respone(msg, "wo ye bu ji dao.");
}

void cs_msg_login(INetClient* client, neb::CJsonObject& msg)
{
	CELLLog_Info("LoginServer::cs_msg_login");
}
```

## 5.2 消息分发机制INetTransfer

在集群结构中， 一种消息可能对应多个INetClient，一个消息可能分发给多个服务

![image-20220512234053546](F:\A3-git_repos\A0-C++Projects\socketEngine\image-20220512234053546.png)

### 5.2.1 建立新类型Listeners

**利用Listeners管理集群，将一种类型的服务器存储在Listeners**

- 将所有的LoginServer存在一起
- 将所有的DBserver存在一起

**需要实现功能**

- 服务器建立连接时(注册时)将其加入`add()`
- 服务器断开连接时(注销时)将其移除`del()`
- 在所有Listeners中选择一个进行消息分发

```c++
//服务监听者(服务集群)
class Listeners
{
public:
	void add(INetClientS* client)
	{
		auto itr = std::find(_listeners.begin(), _listeners.end(), client);
		if (itr == _listeners.end())
		{
			_listeners.push_back(client);
		}
	}

	void del(INetClientS* client)
	{
		auto itr = std::find(_listeners.begin(), _listeners.end(), client);
		if (itr != _listeners.end())
		{
			_listeners.erase(itr);
		}
	}

	INetClientS* get()
	{
		auto size = _listeners.size();

		if (size == 0)
		return nullptr;

		if (size == 1)
			return _listeners[0];

		if (index >= size)
			index = 0;

		return _listeners[index++];
	}
private:
		std::vector<INetClientS*> _listeners;
		int index = 0;
};
```

### 5.2.2 管理Listeners,暴露对外接口

- 利用map管理所有Listeners
- 根据注册请求消息类型cmd增加服务器
- 删除服务器
  - 直接移除
  - 根据cmd删除对应服务
- 响应消息
  - 根据消息类型选择一个服务器进行处理


```c++
private:
	std::map<std::string, Listeners> _msg_listeners;
public:
	void add(std::string cmd, INetClientS* client)
	{
		auto itr = _msg_listeners.find(cmd);
		if (itr != _msg_listeners.end())
		{
			itr->second.add(client);
		}
		else {
			Listeners a;
			a.add(client);
			_msg_listeners[cmd] = a;
		}
	}

	void del(INetClientS* client)
	{
			for (auto& itr: _msg_listeners)
			{
				itr.second.del(client);
			}
	}

	void del(std::string cmd, INetClientS* client)
	{
			auto itr = _msg_listeners.find(cmd);
			if (itr != _msg_listeners.end())
			{
				itr->second.del(client);
			}
	}

	bool on_net_msg_do(std::string& cmd, std::string& data)
	{
		auto itr = _msg_listeners.find(cmd);
		if (itr == _msg_listeners.end())
			return false;

		auto s = itr->second.get();
		if (s)
		{
			s->writeText(data.c_str(), data.length());
			return true;
		}

		return false;
	}
```

### 5.2.3 管理消息分发对象

**在GateServer中定义一个INetTransfer对象**

- 响应客户端的注册请求时，添加该客户端对象
- 客户端离开时，删除该对象

```c++
void ss_reg_api(Server* server, INetClientS* client, neb::CJsonObject& msg)
{
		auto sskey = msg["data"]("sskey");
		auto sskey_local = Config::Instance().getStr("sskey", "ssmm00@123456");
        ....
        ....
		for (size_t i = 0; i < size; i++)
		{
			CELLLog_Info("ss_reg_api: %s >> %s", name.c_str(), apis(i).c_str());
			_transfer.add(apis(i), client);
		}
}

void on_client_leave(INetClientS* client)
{
	if(client->is_ss_link())
	_transfer.del(client);
}
```

