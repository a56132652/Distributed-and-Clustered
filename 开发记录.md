# 1. 封装INetServer与INetClientS

保留底层webSocket通信协议内容

## 1.1 INetServer

**网关服务器**

- **功能**：
  - 注册API
  - 分发消息
  - 限流
    - 限制客户端的请求量，但对于上层服务器的返回的响应消息不进行限流

## 1.2 INetClientS

**用于管理连接的客户端对象**

# 2. 封装INetClient

保留底层webSocket客户端功能 



# 3. 注册网络消息回调

旧版本的消息处理逻辑中，默认已经知道了消息类型，根据接收到的消息的类型来进行不同的处理，这不便于灵活处理消息，因此，为了灵活处理消息，即不论什么消息类型都能回复，**需要提供未知消息类型的注册机制**

## 3.1 利用回调函数注册消息

```c++
typedef std::function<void(Server*, INetClientS*, neb::CJsonObject&)> NetEventCall;
```

**利用map存储事件回调**

```c++
std::map<std::string, NetEventCall> _map_msg_call;
```

**注册消息**

```c++
void reg_msg_call(std::string cmd, NetEventCall call)
	{
		_map_msg_call[cmd] = call;
		CELLLog_Info("INetServer::reg_msg_call cmd<%s>.", cmd.c_str());
	}
```

**根据消息调用回调**

```c++
bool on_net_msg_do(Server* pServer, INetClientS* pWSClient, std::string& cmd, neb::CJsonObject& msgJson)
{
	auto itr = _map_msg_call.find(cmd);
	if (itr != _map_msg_call.end())
	{
		itr->second(pServer, pWSClient, msgJson);
		return true;
	}
	CELLLog_Info("%s::INetServer::on_net_msg_do not found cmd<%s>.", pWSClient->link_name().c_str(), cmd.c_str());
	return false;
}
```

# 4. 建立网关服务器GateServer

**当前，多平台客户端发起的请求都发送给了网关服务器，然后网关服务器进而将请求分发给不同的服务器进行处理，比如登录请求发送给登录服务器，支付请求发送给支付服务器等等。**

## 4.1 在GateServer中注册回调函数

- 注册心跳消息回调函数

```c++
//std::bind() c++11新方法 std::placeholders::_1占位符
/*
可将bind函数看作是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。
调用bind的一般形式：auto newCallable = bind(callable,arg_list);
其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable,并传给它arg_list中的参数。
*/

//收到心跳消息(cs_msg_heart)时调用GateServer::cs_msg_heart()函数
_netserver.reg_msg_call("cs_msg_heart", std::bind(&GateServer::cs_msg_heart, this,std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));

void cs_msg_heart(Server* server, INetClientS* client, neb::CJsonObject& msg)
{
	CELLLog_Info("GateServer::cs_msg_heart");

	neb::CJsonObject ret;
	ret.Add("data", "wo ye bu ji dao.");
	client->response(msg, ret);
	//client->respone(msg, "wo ye bu ji dao.");
}

```

- 注册 注册请求消息 回调函数

```c++
_netserver.reg_msg_call("ss_reg_api", std::bind(&GateServer::ss_reg_api, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));

//响应LoginServer注册服务请求
void ss_reg_api(Server* server, INetClientS* client, neb::CJsonObject& msg)
{
	auto sskey = msg["data"]("sskey");
	auto sskey_local = Config::Instance().getStr("sskey", "ssmm00@123456");
	if (sskey != sskey_local)
	{
		neb::CJsonObject ret;
		//状态码 state 0-fail ,1-success
		ret.Add("state", 0);
		ret.Add("msg", "sskey error.");
		client->response(msg, ret);
		return;
	}
	//客户端类型
	auto type = msg["data"]("type");
	//客户端名称
	auto name = msg["data"]("name");

	client->link_type(type);
	client->link_name(name);
	client->is_ss_link(true);
	/*
        msg["data"]("type"):返回 "type" 字段所对应的字符串
        msg["data"]["apis"]:返回 "apis" 字段所对应的json结构，结构下又包含字符串
	*/
	auto apis = msg["data"]["apis"];

	if (!apis.IsArray())
	{
		neb::CJsonObject ret;
		ret.Add("state", 0);
		ret.Add("msg", "not found apis.");
		client->response(msg, ret);
		return;
	}
	int size = apis.GetArraySize();
	for (size_t i = 0; i < size; i++)
	{
		CELLLog_Info("ss_reg_api: %s >> %s", name.c_str(), apis(i).c_str());
		_transfer.add(apis(i), client);
	}
}
```

- 注册其他消息即客户端离开消息回调

```c++
_netserver.on_other_msg = std::bind(&GateServer::on_other_msg, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4);
_netserver.on_client_leave = std::bind(&GateServer::on_client_leave, this, std::placeholders::_1);

void on_other_msg(Server* server, INetClientS* client, std::string& cmd, neb::CJsonObject& msg)
{
	auto str = msg.ToString();
	if (!_transfer.on_net_msg_do(cmd, str))
	{
		CELLLog_Info("on_other_msg: transfer not found cmd<%s>.", cmd.c_str());
	}
}

void on_client_leave(INetClientS* client)
{
	if(client->is_ss_link())
		_transfer.del(client);
}
```

## 4.2 消息分发机制INetTransfer

在集群结构中， 一种消息可能对应多个INetClient，一个消息可能分发给多个服务

![image-20220512234053546](F:\A3-git_repos\A0-C++Projects\socketEngine\image-20220512234053546.png)

### 4.2.1 建立新类型Listeners

**利用Listeners管理集群，将一种类型的服务器存储在Listeners**

- 将所有的LoginServer存在一起
- 将所有的DBserver存在一起

**需要实现功能**

- 服务器建立连接时(注册时)将其加入`add()`
- 服务器断开连接时(注销时)将其移除`del()`
- 在所有Listeners中选择一个进行消息分发

```c++
//服务监听者(服务集群)
class Listeners
{
public:
	void add(INetClientS* client)
	{
		auto itr = std::find(_listeners.begin(), _listeners.end(), client);
		if (itr == _listeners.end())
		{
			_listeners.push_back(client);
		}
	}

	void del(INetClientS* client)
	{
		auto itr = std::find(_listeners.begin(), _listeners.end(), client);
		if (itr != _listeners.end())
		{
			_listeners.erase(itr);
		}
	}

	INetClientS* get()
	{
		auto size = _listeners.size();

		if (size == 0)
		return nullptr;

		if (size == 1)
			return _listeners[0];

		if (index >= size)
			index = 0;

		return _listeners[index++];
	}
private:
		std::vector<INetClientS*> _listeners;
		int index = 0;
};
```

### 4.2.2 管理Listeners,暴露对外接口

- 利用map管理所有Listeners
- 根据注册请求消息类型cmd增加服务器
- 删除服务器
  - 直接移除
  - 根据cmd删除对应服务
- 响应消息
  - 根据消息类型选择一个服务器进行处理


```c++
private:
	std::map<std::string, Listeners> _msg_listeners;
public:
	void add(std::string cmd, INetClientS* client)
	{
		auto itr = _msg_listeners.find(cmd);
		if (itr != _msg_listeners.end())
		{
			itr->second.add(client);
		}
		else {
			Listeners a;
			a.add(client);
			_msg_listeners[cmd] = a;
		}
	}

	void del(INetClientS* client)
	{
			for (auto& itr: _msg_listeners)
			{
				itr.second.del(client);
			}
	}

	void del(std::string cmd, INetClientS* client)
	{
			auto itr = _msg_listeners.find(cmd);
			if (itr != _msg_listeners.end())
			{
				itr->second.del(client);
			}
	}

	bool on_net_msg_do(std::string& cmd, std::string& data)
	{
		auto itr = _msg_listeners.find(cmd);
		if (itr == _msg_listeners.end())
			return false;

		auto s = itr->second.get();
		if (s)
		{
			s->writeText(data.c_str(), data.length());
			return true;
		}

		return false;
	}
```

### 4.2.3 管理消息分发对象

**在GateServer中定义一个INetTransfer对象**

- 响应客户端的注册请求时，添加该客户端对象
- 客户端离开时，删除该对象

```c++
void ss_reg_api(Server* server, INetClientS* client, neb::CJsonObject& msg)
{
		auto sskey = msg["data"]("sskey");
		auto sskey_local = Config::Instance().getStr("sskey", "ssmm00@123456");
        ....
        ....
		for (size_t i = 0; i < size; i++)
		{
			CELLLog_Info("ss_reg_api: %s >> %s", name.c_str(), apis(i).c_str());
			_transfer.add(apis(i), client);
		}
}

void on_client_leave(INetClientS* client)
{
	if(client->is_ss_link())
	_transfer.del(client);
}
```

## 4.3 服务端响应请求

客户端发送请求给网关服务器，然后网关将请求分发给上层的服务器，服务器处理完请求以后，将响应消息返回给网关，然后网关再将响应消息返回给对应客户端

- 上层服务器发送的消息分为两种

  - 一是注册请求
  - 而是响应客户端的消息

- 对于上层服务器不同的消息类型需要进行不同的处理

  - 上层服务器发送的消息中新增字段用于标识该消息是响应报文还是请求报文
  - 还需要对客户端建立标识clientId

- 服务端响应

  ```c++
  //服务端响应
  bool is_resp = false;
  if (json.Get("is_resp", is_resp) && is_resp)
  {
  	if (!pWSClient->is_ss_link())
  	{
  		CELLLog_Error("pWSClient->is_ss_link=false, is_resp=true.");
  		return;
  	}
  
  	int clientId = 0;
  	if (!json.Get("clientId", clientId))
  	{
  		CELLLog_Error("not found key<%s>.", "clientId");
  		return;
  	}
  
  	auto client = dynamic_cast<INetClientS*>(pServer->find_client(clientId));
  	if (!client)
  	{
  		CELLLog_Error("INetServer::OnNetMsgWS::pServer->find_client(%d) miss.", clientId);
  		return;
  	}
  	if (SOCKET_ERROR == client->writeText(dataStr, wsh.len))
  	{
  		CELLLog_Error("INetServer::OnNetMsgWS::sslink(%s)->clientId(%d) writeText SOCKET_ERROR.", pWSClient->link_name().c_str(), clientId);
  	}
  
  	return;
  }
  ```

- 服务端请求

  ```c++
  if (is_req)
  {
  	std::string cmd;
  	if (!json.Get("cmd", cmd))
  	{
  		CELLLog_Error("not found key<%s>.", "cmd");
  		return;
  	}
  
  	int clientId = (int)pWSClient->sockfd();
  	json.Add("clientId", clientId);
  
  	if (on_net_msg_do(pServer, pWSClient, cmd, json))
  		return;
  
  	on_other_msg(pServer, pWSClient, cmd, json);
  
  	return;
  }
  ```

  



# 5. 建立登录服务器LoginServer

**登陆服务器首先与网关服务器建立连接，在该`C~S`模型中LoginServer为客户端，GateServer为服务端**

- LoginServer首先发起连接请求，连接完成后向GateServer发起注册服务请求
  - 即告知GateServer自己关注何种类型的消息，注册成功后，当GateServer收到该类型消息时，会将其分发给LoginServer

## 5.1 注册回调函数

- 注册 onopen 回调

```c++
_csGate.reg_msg_call("onopen", std::bind(&LoginServer::onopen_csGate, this, std::placeholders::_1, std::placeholders::_2));
//收到 onopen 消息时的回调，收到onopen消息后向网关服务器发起注册服务请求
void onopen_csGate(INetClient* client, neb::CJsonObject& msg)
{
	neb::CJsonObject json;
	//告知网关自己是什么类型的服务
	json.Add("type", "LoginServer");
	//自己的名字
	json.Add("name", "LoginServer001");
	//校验机制，网关服务器会校验该值
	json.Add("sskey", "ssmm00@123456");
	json.AddEmptySubArray("apis");
	/*
		告知网关自己关心什么类型的消息
		网关收到该类型的消息到会分发给自己
	*/
	//登录
	json["apis"].Add("cs_msg_login");
	//注册
	json["apis"].Add("cs_msg_register");
	//改密码
	json["apis"].Add("cs_msg_change_pw");
	client->request("ss_reg_api", json);
}
```

- 心跳消息以及登录消息回调

```c++
_csGate.reg_msg_call("cs_msg_heart", std::bind(&LoginServer::cs_msg_heart, this,std::placeholders::_1, std::placeholders::_2));
_csGate.reg_msg_call("cs_msg_login", std::bind(&LoginServer::cs_msg_login, this, std::placeholders::_1, std::placeholders::_2));

void cs_msg_heart(INetClient* client, neb::CJsonObject& msg)
{
	CELLLog_Info("LoginServer::cs_msg_heart");

	neb::CJsonObject ret;
	ret.Add("data", "wo ye bu ji dao.");
	client->response(msg, ret);

	//client->respone(msg, "wo ye bu ji dao.");
}

void cs_msg_login(INetClient* client, neb::CJsonObject& msg)
{
	CELLLog_Info("LoginServer::cs_msg_login");
}
```

# 6. 自动连接网关

实现断线后自动重连网关服务器的功能

## 6.1 LoginServer自动重连

调用run()时，若正在运行，则执行OnRun(),否则，进行connect()

```c++
bool run()
{
	if(_client.isRun())
        return _client.OnRun();
    else
        if(_client_connect(_url.c_str())){
            return true;
        }
    return false;
}
```

## 6.2 LoginServer定时发送心跳包到网关

加入心跳计时，设置为5秒，当计时器超过5秒时，向网关发送一个心跳消息包

```c++
bool run(int microseconds = 1)
{
	if (_client.isRun())
	{	
		//超过5秒
		if (_time2heart.getElapsedSecond() > 5.0)
		{
			//重置计时器
			_time2heart.update();
			neb::CJsonObject json;
			//向网关服务端发送心跳消息，消息为空
			request("cs_msg_heart", json);
		}
		return _client.OnRun(microseconds);
	}

		if (_client.connect(_url.c_str()))
		{
			//连接上服务端以后重置心跳计时器
			_time2heart.update();
			CELLLog_Warring("%s::INetClient::connect(%s) success.", _link_name.c_str(), _url.c_str());
			return true;
		}
		return false;
}
```

# 7. INetClient请求回调

- LoginServer作为响应方响应消息时，通过接受的消息的cmd字段调用之前注册的方法

  ```c++
  void reg_msg_call(std::string cmd, NetEventCall call){....}
  bool on_net_msg_do(const std::string& cmd, neb::CJsonObject& msgJson){....}
  ```

- LoginServer作为请求方向网关发起请求时，接收到网关服务器的响应时，调用回调函数

  - 利用msgId存储

  ```c++
  //发送消息时注册回调函数
  client->request("ss_reg_api", json, [](INetClient* client, neb::CJsonObject& msg) {
  		CELLLog_Info(msg("data").c_str());
  	});
  //发起请求时带上回调方法
  void request(const std::string& cmd, neb::CJsonObject& data, NetEventCall call)
  {
  	_time2heart.update();
  
  	neb::CJsonObject msg;
  	msg.Add("cmd", cmd);
  	msg.Add("is_req", true, true);
  	msg.Add("msgId", ++msgId);
  	_map_request_call[msgId] = call;
  
  	msg.Add("time", Time::system_clock_now());
  	msg.Add("data", data);
  
  	std::string retStr = msg.ToString();
  	_client.writeText(retStr.c_str(), retStr.length());
  }
  
  //接收到网关响应消息时，根据msgId调用之前存储的回调函数
  bool is_resp = false;
  if (json.Get("is_resp", is_resp) && is_resp)
  {  
  	on_net_msg_do(msgId, json);
  	return;
  }
  
  //通过msgId存储回调
  bool on_net_msg_do(int msgId, neb::CJsonObject& msgJson){....}
  
  ```

# 8. 实现各种类型客户端

- C++客户端
- node.js客户端
- web.js客户端

# 9. LoginServer实现账号注册功能

## 9.1利用正则表达式判断字段是否合理

`std::regex reg1("^[0-9a-zA-Z]{6,16}$");`

- 整个字符串必须是字母或数字，无论大小写，长度为[6,16]

```c++
void cs_msg_register(INetClient* client, neb::CJsonObject& msg)
{
    ...
}

```

## 9.2 使用Sqlite数据库存储数据

### 9.2.1 对外操作接口

- 打开数据库
- 关闭数据库
- 查询是否有重复数据

```c++
class DBManager
{
protected:
	CppSQLite3DB _db;
	std::string _db_name;
public:
	bool open(const char* db_name)
	{
		_db_name = db_name;
		try
		{
			_db.open(db_name);
			return true;
		}
		catch (CppSQLite3Exception& e)
		{
			CELLLog_Error("DBManager::open(%s) error: %s", db_name, e.errorMessage());
		}
		return false;
	}

	bool close()
	{
		try
		{
			_db.close();
			return true;
		}
		catch (CppSQLite3Exception& e)
		{
			CELLLog_Error("DBManager::close(%s) error: %s", _db_name.c_str(), e.errorMessage());
		}
		return false;
	}

	bool hasByKV(const char* table, const char* k, const char* v)
	{
		char sql_buff[1024] = {};
		auto sql = "SELECT 1 FROM %s WHERE %s='%s' LIMIT 1;";
		sprintf(sql_buff, sql, table, k, v);

		try
		{
			CppSQLite3Query query = _db.execQuery(sql_buff);
			return !query.eof();
		}
		catch (CppSQLite3Exception& e)
		{
			CELLLog_Error("DBManager::hasByKV(%s) error: %s", _db_name.c_str(), e.errorMessage());
		}
		return false;
	}
};
```

# 10. 修改密码

## 10.1 注册

```c++
void cs_msg_change_pw(INetClient* client, neb::CJsonObject& msg){...}
```

## 10.2 查询并返回json格式数据

```c++
bool findByKV(const char* table, const char* k, const char* v, neb::CJsonObject& json){...}
```



## 10.3 使用模板方法以及stringstream优化数据操作接口



## 10.4 删除数据操作

# 11. Sqlite性能测试

## 11.1 使用事务操作

```
db.execDML("begin;");

db.execDML("commit;");
```

插入数据时先将数据插入缓存，提交后存入磁盘，减少了磁盘IO，插入效率得到了极大提升

- 100万次insert操作耗时12s
- 100万次select操作耗时7s

## 11.2 定时提交事务

DBUser初始化时开启事务，每隔10秒提交一次 

```c++
//DBUser::init()
void init()
{
	...
	//开启事务
	begin();
	
	...
}

//DBManager
void begin()
{
	execDML("begin;");
}

void commit()
{
	execDML("commit;");
}

void run()
{ 
	if (_timestamp.getElapsedSecond() > 10.0)
	{
		//每10s提交一次
		commit();
		//重置计时器
		_timestamp.update();
		//开启事务
		begin();
	}
}
```

# 12.分布式与集群中的登陆服务

实现管理更严格的登录服务

- 仅允许一个连接登录一个账号，另一个连接登录该账号时必须先踢掉另一个连接，即不允许同时登陆

![image-20220518213615982](F:\A3-git_repos\A0-C++Projects\socketEngine\image-20220518213615982.png)

**登录令牌：**

- 用以验证用户身份，用户下次连接时直接利用TOKEN进行身份验证

![image-20220518213828912](F:\A3-git_repos\A0-C++Projects\socketEngine\image-20220518213828912.png)

## 12.1发起登录请示

- 从报文中取出用户名以及密码并验证合理性
- 根据用户名从数据库中取出对应用户的数据并对密码进行比对，验证是否一致
- 取出`UserId`，判断该用户当前是否在线
  - 若在线
    - 通知已登录用户异地登陆消息
    - 通知网关用户登出`GateServer::ss_msg_user_loginout()`:LoginServer通知网关用户登出
    - 将已登录用户移除
- 根据`UserId`以及`clientId`生成token
- 记录token,关联用户数据
  - 定义`UserManager`用于登陆服务器管理用户token
- 通知网关用户登录：`GateServer::ss_msg_user_login()`:LoginServer通知网关用户登录
- 返回登陆结果

```c++
_ss_gate.reg_msg_call("ss_msg_user_logout", ...);
_ss_gate.reg_msg_call("ss_msg_user_login", ...);

//GateServer::ss_msg_user_login() LoginServer通知网关用户登录
void ss_msg_user_login(INetClient* client, neb::CJsonObject& msg)
{
	int clientId = 0;
	if (!msg["data"].Get("clientId", clientId))
	{
		CELLLog_Error("not found key<clientId>.");
		return;
	}

	int64_t userId = 0;
	if (!msg["data"].Get("userId", userId))
	{
		CELLLog_Error("not found key<userId>.");
		return;
	}

	std::string token;
	if (!msg["data"].Get("token", token))
	{
		CELLLog_Error("not found key<token>.");
		return;
	}

	clientId = ClientId::get_client_id(clientId);
	auto clientS = dynamic_cast<INetClientS*>(_netserver.find_client(clientId));
	if (!clientS)
	{
		CELLLog_Error("LinkServer::ss_msg_user_login::server->find_client(%d) miss.", clientId);
		return;
				}

	clientS->userId(userId);
	clientS->token(token);
				//CELLLog_Info("LinkServer::ss_msg_user_login::clientId<%d>userId<%lld>.", clientId, userId);
}
//GateServer::ss_msg_user_loginout() LoginServer通知网关用户登出
void ss_msg_user_logout(INetClient* client, neb::CJsonObject& msg)
{
	int clientId = 0;
	if (!msg["data"].Get("clientId", clientId))
	{
		CELLLog_Error("not found key<clientId>.");
		return;
	}

	int64_t userId = 0;
	if (!msg["data"].Get("userId", userId))
	{
		CELLLog_Error("not found key<userId>.");
		return;
	}

	std::string token;
	if (!msg["data"].Get("token", token))
	{
		CELLLog_Error("not found key<token>.");
		return;
	}

	clientId = ClientId::get_client_id(clientId);
	auto clientS = dynamic_cast<INetClientS*>(_netserver.find_client(clientId));
	if (!clientS)
	{
		CELLLog_Error("LinkServer::ss_msg_user_logout::server->find_client(%d) miss.", clientId);
		return;
	}

		if (userId != clientS->userId())
		{
			CELLLog_Error("LinkServer::ss_msg_user_logout::userId<%lld> != clientS->userId<%lld>.", userId, clientS->userId());
			return;
		}

		clientS->userId(0);
		clientS->token("");
				//CELLLog_Info("LinkServer::ss_msg_user_logout::clientId<%d>userId<%lld>.", clientId, userId);
}
```



## 12.2 增加消息请求超时处理机制

服务端可能由于某种原因，在一定时间内未对请求做出相应，此时应超出超时反馈 

**超时机制：**

- 给请求添加一个时间属性，标识其是什么时间发的，若一段时间后未得到响应，则进行超时反馈

  ```c++
  //对请求添加时间属性，标识该请求是什么时间发送的，用于超时反馈
  struct NetEventCallData {
  	NetEventCall callFun = nullptr;
  	time_t dt = 0;
  };
  
  std::map<int, NetEventCallData> _map_request_call;
  
  //请求超时检测
  void check_timeout()
  {
  	//如果_timeout_dt为0  就不检测超时
  	if (0 == _timeout_dt)
  		return;
  
  	time_t now = Time::system_clock_now();
  	for (auto itr = _map_request_call.begin(); itr != _map_request_call.end(); )
  	{
  		if (now - itr->second.dt >= _timeout_dt)
  		{
  			//该请求触发超时
  			itr->second.callFun(this, _ret_timeout);
  			//移除该请求的响应回调
  			auto itrOld = itr;
  			++itr;
  			_map_request_call.erase(itrOld);
  			continue;
  		}
  			++itr;
  	}
  	}
  ```

  

## 12.3 增加消息请求失败处理机制

**GateServer**

```c++
void on_other_msg(Server* server, INetClientS* client, std::string& cmd, neb::CJsonObject& msg)
{
	auto str = msg.ToString();
	int ret = _transfer.on_net_msg_do(cmd, str);
	if (state_code_undefine_cmd == ret)
	{
		CELLLog_Info("on_other_msg: transfer not found cmd<%s>.", cmd.c_str());
			client->response(msg, "undefine cmd!", state_code_undefine_cmd);
		}
	else if (state_code_server_busy == ret)
	{
		CELLLog_Info("on_other_msg: server busy! cmd<%s>.", cmd.c_str());
		client->response(msg, "server busy!", state_code_server_busy);
	}
	else if (state_code_server_off == ret)
	{
		CELLLog_Info("on_other_msg: server offline! cmd<%s>.", cmd.c_str());
		client->response(msg, "server offline!", state_code_server_off);
	}
}
```

## 12.4 通过token登录

与密码登录类似，服务端取出token进行验证

UserClient注册时，若有token，则json中带上token

```c++
//注册客户端
void reg_client(){
	if (!_token.empty())
		json.Add("token", _token);
}
```

单独token登录方法

```c++
//利用token登录
void login_by_token()
{
	neb::CJsonObject json;
	json.Add("token", _token);

	_csGate.request("cs_msg_login_by_token", json, [this](INetClient* client, neb::CJsonObject& msg) {
	....});
}
```





# 13. 会话组服务

## 13.1 会话组创建

1. 鉴定权限
   - 请求者是否具备创建group的权限
   - 只有已登录的Client或者已验证Server有权限
   
   ```c++
   int clientId = 0;
   if (!msg.Get("clientId", clientId))
   {
   	CELLLog_Error("not found key<clientId>.");
   	return;
   }
   
   bool is_ss_link = false;
   msg.Get("is_ss_link", is_ss_link);
   
   int64_t userId = 0;
   msg.Get("userId", userId);
   //未登录并且不是上层服务器
   if (userId == 0 && !is_ss_link)
   {
   	client->resp_error(msg, "not login!");
   	return;
   }
   ```
   
   
   
2. group的id
   1. 可以请求者提供，也可以是服务器来分配
   
3. group的key
   1. 可以请求者提供，也可以是服务器来分配

## 13.2 会话组管理





# 14. 结构升级

![image-20220524222108386](F:\A3-git_repos\A0-C++Projects\socketEngine\image-20220524222108386.png)

结构升级，使用业务网关去管理客户端，利用中心控制服务控制所有业务网关以及所有上层服务器

## 14.1 LinkServer(业务网关)

